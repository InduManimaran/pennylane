# Copyright 2018 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Integration tests for templates, including integration of passing outputs of initialization functions
in :mod:`pennylane.init`, and running templates in larger circuits.
"""
# pylint: disable=protected-access,cell-var-from-loop
import pytest
import numpy as np
import pennylane as qml
from pennylane.templates.layers import (CVNeuralNetLayers, CVNeuralNetLayer,
                                        StronglyEntanglingLayers, StronglyEntanglingLayer,
                                        RandomLayers, RandomLayer)
from pennylane.init import (strong_ent_layers_uniform, strong_ent_layer_uniform,
                            strong_ent_layers_normal, strong_ent_layer_normal,
                            random_layers_uniform, random_layer_uniform,
                            random_layers_normal, random_layer_normal,
                            cvqnn_layers_uniform, cvqnn_layer_uniform,
                            cvqnn_layers_normal, cvqnn_layer_normal)


class TestParameterIntegration:
    """Tests integration with the parameter initialization functions from pennylane.init"""

    @pytest.mark.parametrize('parfun', [cvqnn_layers_uniform, cvqnn_layers_normal])
    def test_init_integration_cvqnn_layers(self, parfun, gaussian_device, n_subsystems, n_layers):
        """Checks that pennylane.init.cvqnn_layers_uniform() integrates
        with pennnylane.templates.layers.CVNeuralNetLayers()."""

        p = parfun(n_layers=n_layers, n_wires=n_subsystems)

        @qml.qnode(gaussian_device)
        def circuit(weights):
            CVNeuralNetLayers(*weights, wires=range(n_subsystems))
            return qml.expval(qml.Identity(0))

        circuit(weights=p)

    @pytest.mark.parametrize('parfun', [cvqnn_layer_uniform, cvqnn_layer_normal])
    def test_init_integration_cvqnn_layer(self, parfun, gaussian_device, n_subsystems):
        """Checks that parameters generated by methods from pennylane.init integrate
        with pennnylane.templates.layers.CVNeuralNetLayer()."""

        p = parfun(n_wires=n_subsystems)

        @qml.qnode(gaussian_device)
        def circuit(weights):
            CVNeuralNetLayer(*weights, wires=range(n_subsystems))
            return qml.expval(qml.Identity(0))

        circuit(weights=p)

    @pytest.mark.parametrize('parfun', [strong_ent_layers_uniform, strong_ent_layers_normal])
    def test_init_integration_stronglyentangling_layers(self, parfun, qubit_device, n_subsystems, n_layers):
        """Checks that parameters generated by methods from pennylane.init integrate
        with pennnylane.templates.layers.StronglyEntanglingLayers()."""

        p = parfun(n_layers=n_layers, n_wires=n_subsystems)

        @qml.qnode(qubit_device)
        def circuit(weights):
            StronglyEntanglingLayers(*weights, wires=range(n_subsystems))
            return qml.expval(qml.Identity(0))

        circuit(weights=p)

    @pytest.mark.parametrize('parfun', [strong_ent_layer_uniform, strong_ent_layer_normal])
    def test_init_integration_stronglyentangling_layer(self, parfun, qubit_device, n_subsystems):
        """Checks that parameters generated by methods from pennylane.init integrate
        with pennnylane.templates.layers.StronglyEntanglingLayer()."""

        p = parfun(n_wires=n_subsystems)

        @qml.qnode(qubit_device)
        def circuit(weights):
            StronglyEntanglingLayer(*weights, wires=range(n_subsystems))
            return qml.expval(qml.Identity(0))

        circuit(weights=p)

    @pytest.mark.parametrize('parfun', [random_layers_uniform, random_layers_normal])
    def test_init_integration_random_layers(self, parfun, qubit_device, n_subsystems, n_layers):
        """Checks that parameters generated by methods from pennylane.init integrate
        with pennnylane.templates.layers.RandomLayers()."""

        p = parfun(n_layers=n_layers, n_wires=n_subsystems)

        @qml.qnode(qubit_device)
        def circuit(weights):
            RandomLayers(*weights, wires=range(n_subsystems))
            return qml.expval(qml.Identity(0))

        circuit(weights=p)

    @pytest.mark.parametrize('parfun', [random_layer_uniform, random_layer_normal])
    def test_init_integration_random_layer(self, parfun, qubit_device, n_subsystems):
        """Checks that parameters generated by methods from pennylane.init integrate
        with pennnylane.templates.layers.RandomLayer()."""

        p = parfun(n_wires=n_subsystems)

        @qml.qnode(qubit_device)
        def circuit(weights):
            RandomLayer(*weights, wires=range(n_subsystems))
            return qml.expval(qml.Identity(0))

        circuit(weights=p)


class TestCircuitIntegration:
    """Tests the integration of templates into larger circuits."""

    def test_circuit_integration_cvqnn_layers(self, gaussian_device_2_wires):
        """Checks that parameters generated by methods from pennylane.init integrate
        with pennnylane.templates.layers.StronglyEntanglingLayers()."""

        p = [np.array([[2.33312851], [1.20670562]]),
             np.array([[3.49488327], [2.01683706]]),
             np.array([[0.9868003, 1.58798724], [5.06301407, 4.83852562]]),
             np.array([[0.21358641,  0.120304], [-0.00724019, 0.01996744]]),
             np.array([[4.62040076, 6.08773452], [6.09056998, 6.22395862]]),
             np.array([[4.10336783], [1.70001985]]),
             np.array([[4.74112903], [5.31462729]]),
             np.array([[0.89758198, 0.41604762], [1.09680782, 3.08223802]]),
             np.array([[-0.0807571, -0.00908855], [0.06051908, -0.1667079]]),
             np.array([[1.87210909, 3.59695024], [1.42759279, 3.84330071]]),
             np.array([[0.00389139,  0.05125553], [-0.12120044,  0.03111934]])
             ]

        @qml.qnode(gaussian_device_2_wires)
        def circuit(weights):
            qml.Displacement(1., 1., wires=0)
            CVNeuralNetLayers(*weights, wires=range(2))
            CVNeuralNetLayers(*weights, wires=range(2))
            qml.Displacement(1., 1., wires=1)
            return [qml.expval(qml.Identity(0)), qml.expval(qml.X(1))]

        circuit(weights=p)

    def test_circuit_integration_stronglyentangling_layers(self):
        """Checks that parameters generated by methods from pennylane.init integrate
        with pennnylane.templates.layers.StronglyEntanglingLayers()."""

        p = np.array([[[1.50820225, 4.24049172, 5.58068076],
                       [3.72927363, 5.4538957, 1.21793098]],
                      [[5.25049813, 1.11059904, 0.52967773],
                       [4.9789569, 1.42562158, 2.49977512]]])
        dev = qml.device('default.qubit', wires=2)

        @qml.qnode(dev)
        def circuit(weights):
            qml.PauliX(wires=0)
            StronglyEntanglingLayers(weights, wires=range(2))
            StronglyEntanglingLayers(weights, wires=range(2))
            qml.PauliX(wires=1)
            return [qml.sample(qml.Identity(0)), qml.expval(qml.PauliX(1))]

        circuit(weights=p)

    def test_circuit_integration_random_layers(self):
        """Checks that parameters generated by methods from pennylane.init integrate
        with pennnylane.templates.layers.RandomLayer()."""

        p = np.array([[0.53479316, 5.88709314],
                      [2.21352321, 4.28468607]])
        dev = qml.device('default.qubit', wires=2)

        @qml.qnode(dev)
        def circuit(weights):
            qml.PauliX(wires=0)
            RandomLayers(weights, wires=range(2))
            RandomLayers(weights, wires=range(2))
            qml.PauliX(wires=1)
            return [qml.sample(qml.Identity(0)), qml.expval(qml.PauliX(1))]

        circuit(weights=p)
